# 1. refer link
- https://en.wikipedia.org/wiki/Thread_(computing)
- https://en.wikipedia.org/wiki/Thread_safety


# 2.定义
- 进程的组件
- 一个进程包含多个线程
- 线程之间共享进程的执行代码，变量等



# 3.单核和多核
- 单核通过时间片实现多线程，不断切换context来运行不同的线程
- 多核可以做到每个处理器执行一个线程


# 4.用户级线程和内核级线程
## 4.1 内核级线程
- 切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。
- 切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。
- windows线程就是这样的
- 由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。
- 一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。Windows NT和2000/XP支持内核线程。

### 4.1.1 实现方式
- 系统在分给进程几个轻型进程（LWP），
- LWP可以通过系统调用来获得内核提供的服务，
- 而进程中的用户线程可通过复用来关联到LWP，从而得到内核的服务。

### 4.1.2 优缺点
- 优点:当有多个处理机时，一个进程的多个线程可以同时执行。
- 缺点：由内核进行调度。

## 4.2 用户级线程
- 应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
- 内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的。
- 操作系统内核不知道多线程的存在，因此一个线程阻塞会使整个进程(包含其他所有线程阻塞)


### 4.2.1 实现方式
- “运行时系统”实质上是用于管理和控制线程的函数集合，包括创建、撤销、线程的同步和通信的函数以及调度的函数。
- 这些函数都驻留在用户空间作为用户线程和内核之间的接口。
- 用户线程不能使用系统调用，而是当线程需要系统资源时，将请求传送给运行时，由后者通过相应的系统调用来获取系统资源。


### 4.2.2 优缺点
#### 4.2.2.1 优点
- 线程的调度不需要内核直接参与，控制简单。

- 可以在不支持线程的操作系统中实现。

- 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。

- 允许每个进程定制自己的调度算法，线程管理比较灵活。

- 线程能够利用的表空间和堆栈空间比内核级线程多。

#### 4.2.2.2 缺点
- 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。

## 4.3 用户级线程和内核级线程区别
- 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。
- 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；
- 而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。
- 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。
- 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；
- 在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。
- 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。

# 5.阻塞处理方法
- fiber和thread都不能使用阻塞io，或导致整个进程阻塞以及其他的thread or fiber一起阻塞
- 遇到io操作，需要用非阻塞方法代替，在io操作就绪后，在切换到thread or fiber继续执行


# 6.调度模型
- 依据线程和内核调度单位的对应关系分为1:1(内核线程) (N:1)用户线程  (N:M)(复杂的实现关系)

# 7.线程安全
