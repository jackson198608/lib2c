# 1.refer link

# 2.基本原理
- 一般而言，进程有单独的地址空间。那么，在进程A中声明的数据对于进程B是不可用的。而且，进程B看不到进程A中发生的事件，反之亦然。
- 如果进程A和B一起工作来完成某个任务，必须有一个在两个进程间通信信息和时间的方法。
- 数据对于其它进程来说是受保护的。为了让一个进程访问另外一个进程的数据，必须最终使用操作系统调用。
- 与之类似，为了让一个进程知道另一个进程中文本片断中发生的事件，必须在进程间建立一种通信方式。- 当进程将数据发送到另一进程时，称做IPC


# 3.通信方式
## 3.1 环境变量/文件描述符
- 当创建一个子进程时，它接受了父进程许多资源的拷贝。
- 子进程接受了父进程的文本、堆栈以及数据片断的拷贝。
- 子进程也接受了父进程的环境数据以及所有文件描述符的拷贝。
- 子进程从父进程继承资源的过程创造了进程间通信的一个机会。父进程可以在它的数据片断或环境中设置一定的变量，子进程于是接受这些值。
- 同样，父进程也可以打开一个文件，推进到文件内的期望位置，子进程接着就可以在父进程离开读/写指针的准确位置访问该文件。
- 这种属于一次性通信


## 3.2 命令行参数
- 这个一样属于一次性参数
- 属于exec系统调用生成子进程的时候使用


## 3.3 管道
- 管道是一种数据结构，像一个序列化文件一样访问。
- 它形成了两个进程间的一种通信渠道。管道结构通过使用文本和写方式来访问。
- 如果进程A希望通过管道发送数据给进程B，那么进程A向管道写入数据。
- 为了让进程B接收此数据，进程B必须读取管道。
- 管道可以双向通信。两进程间的数据流是双向通信的。
- 有意思的两个图分享一下
- ![demo](http://p.blog.csdn.net/images/p_blog_csdn_net/masefee/EntryImages/20090513/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93633778226738437500.jpg "没有通信之前")
- ![demo](http://p.blog.csdn.net/images/p_blog_csdn_net/masefee/EntryImages/20090513/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%931633778226739062500.jpg "建立管道之后")


### 3.3.1 无名管道(pipe)
#### 3.3.1.1 简介以及原理 
- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道
- 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件
- 它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
- 数据的读出和写入遵循队列的操作方式
- 向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。当管道满时，读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。
- 只有管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIGPIPE信号，应用程序可以处理该信号，也可以忽略(默认动作则是使应用程序终止)。


#### 3.3.1.2 相关系统调用
##### 3.3.1.2.1 pipe
- https://linux.die.net/man/2/pipe 
 
```c
#include <unistd.h>
int pipe(int pipefd[2]);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include<fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int pipe2(int pipefd[2], int flags);
```

- 输入为一个数组，系统调用会填充两个元素，0为读端，1为写端
- 接下来的操作和操作fd一样，读取或者写入
- 父子进程可以相应的关闭不需要的一端
