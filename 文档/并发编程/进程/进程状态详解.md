# 1.refer Link
- https://en.wikipedia.org/wiki/Process_state


# 2.各种状态
- ![demo](https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Process_states.svg/600px-Process_states.svg.png "logo图片")


## 2.1 create状态
- 初始状态，有的也就"new"状态
- 在这个状态下，进程在等待操作系统一个许可，进入"ready"状态。
- 很多桌面操作系统会自动的给进程进入ready状态的许可
- 实时操作系统则会延迟发放许可。


## 2.2 ready状态
- 进程被加载进入内存,等待被cpu执行。
- 单核系统中很多都是处于ready状态，同一时间只能有1个进程处于执行状态，
- cpu有自己的ready队列，调度基于队列执行
- 系统同一时间，除了ready,runnning,之外还有一些其他的进程在等待事件发生，比如io。事件发生后，重新变成ready状态。进入ready队列

## 2.3 running状态
- 进程被cpu选定执行之后，进入running状态
- 进程被cpu具体的core选中
- 进程运行有两种形态，内核态和用户态

### 2.3.1 内核态
- 即可以访问内核的地址空间,又可以访问用户的地址空间
- 允许直接硬件操作指令
- 很多指令只能在内核态执行，比如IO操作
- 系统调用只能在内核态执行

### 2.3.2 用户态
- 只可以访问用户级的数据和指令
- 只可以访问用户的地址空间
- 执行的是用户的应用程序的情况下，进程初始执行在用户态，当进程需要进行只有内核态才能操作的指令时，就会切换到内核态执行


## 2.4 block状态
- 进程等待event，会从running状态进入block状态
- 进程耗尽分配给的cpu时间也会进入block状态而不是ready状态?

## 2.5 terminated状态
- 完成执行后会从running状态进入terminated状态
- 进程从外部被kill，会进入terminated状态
- 会变成僵尸进程?
- 父进程调用wait系统调用会回收僵尸子进程
